# BLEすれ違い通信 技術方針設計書 (BLE Design Policy)

## 1. 概要

本ドキュメントは、「Campus Connect」アプリのコア機能であるBLE（Bluetooth Low Energy）を利用したユーザー間のすれ違い通信機能に関する、技術的な仕様と設計方針を定義するものである。

## 2. アーキテクチャ

BLE通信機能の実装は、以下のアーキテクチャを採用する。

* **方針:** **ネイティブ実装 + Platform Channel**
* **理由:**
    * BLEのようにOSの低レベルな機能を扱う場合、バックグラウンド動作の安定性やパフォーマンス、OSバージョンごとの差異の吸収においてネイティブ実装が最も堅牢であるため。
    * OS固有の高度な機能（AndroidのForeground Service、iOSのState Restoration）を最大限に活用できる。
* **役割分担:**
    * **ネイティブ層 (Swift / Kotlin):**
        * BLEの初期化、パーミッション管理
        * アドバタイズ（発信）の開始・停止
        * スキャン（受信）の開始・停止
        * バックグラウンド実行に関する処理
        * スキャンで検知したデータをPlatform Channel経由でFlutter層に通知する。
    * **Flutter層 (Dart):**
        * UIからの指示に基づき、Platform Channelを介してネイティブ層の処理（スキャン開始など）を呼び出す。
        * ネイティブ層から受け取った「一時ID」を、リポジトリ経由でバックエンドAPIに送信する。

## 3. 一時IDの生成と管理

ユーザーのプライバシーを保護しつつ、バックエンドで正確なすれ違い記録を照合するため、以下の方式を採用する。

* **方針:** **バックエンド生成方式**
* **理由:**
    * クライアント側のロジックがシンプルになり、実装の不具合が起きにくい。
    * 一時IDが万が一漏洩しても、それが誰のIDかを第三者が特定することが極めて困難であり、セキュリティが高い。
* **処理フロー:**
    1.  **ID取得:** クライアントは、バックエンドのID発行用エンドポイント (`POST /api/auth/temporary-id`) にリクエストを送信する。
    2.  **ID生成・保存:** バックエンドは、リクエスト元のユーザーと紐付けた、暗号学的に安全なランダムな**一時ID (tempId)** を生成する。このIDには**有効期限（例: 15分）**を設定し、データベースに保存する (`(userId, tempId, expirationAt)`)。
    3.  **ID返却:** バックエンドは、生成した `tempId` のみクライアントに返却する。
    4.  **アドバタイズ:** クライアントは受け取った `tempId` をアドバタイズパケットに乗せて発信する。
    5.  **スキャンと報告:** 他のクライアントは、この `tempId` をスキャンし、すれ違い記録用エンドポイント (`POST /api/encounters`) に報告する。
    6.  **照合:** バックエンドは報告された `tempId` をデータベースで照合し、有効期限内であれば、対応するユーザー同士のすれ違いを記録する。

## 4. API通信とオフライン対応

すれ違い検知時のAPI通信は、開発フェーズを考慮し段階的に実装する。

* **方針（フェーズ1: 初期実装）:** **即時処理**
    * **内容:** すれ違いを検知するたびに、都度 `POST /api/encounters` を呼び出す。
    * **理由:** まずは機能を確実に動作させることを目的とし、最もシンプルな実装を選択する。
* **方針（フェーズ2: 将来的な最適化）:** **バッチ処理 + オフライン対応**
    * **内容:** 検知したIDをローカルDBに複数保存し、一定数溜まるか一定時間経過したタイミングでまとめてAPIに送信する。
    * **理由:** API呼び出し回数を削減し、通信量とバッテリー消費を抑制する。また、オフライン環境でのすれ違いも記録できるようにする。

## 5. バッテリー消費対策

BLEの常時動作によるバッテリー消費については、API通信と同様に段階的な対応を行う。

* **方針（フェーズ1: 初期実装）:** **特別な対策は行わない**
    * **内容:** 常に一定の間隔でスキャンとアドバタイズを行う。
    * **理由:** まずは基本機能のテストと動作の安定を最優先する。
* **方針（フェーズ2: 将来的な最適化）:** **動的な制御の導入**
    * **内容:**
        * アプリの状態（フォアグラウンド/バックグラウンド）に応じてスキャン間隔を調整する。
        * 加速度センサー等を利用し、ユーザーが長時間静止している場合はスキャン間隔を長くする、または停止する。
    * **理由:** ユーザー体験を向上させるため、バッテリー寿命を可能な限り維持する。

## 6. バックグラウンド動作の許容レベル

モバイルOSによるバックグラウンド動作の制約については、以下の方針とする。

* **方針:** **OSの制約を前提とする（ベストエフォート）**
* **理由:**
    * OSの制約に反する実装は、アプリの不安定化やリジェクトのリスクを伴うため。
    * 追加の技術調査や実装にかかる開発コストを抑制するため。
* **具体的な仕様:**
    * **Android:** Foreground Serviceを利用し、ユーザーには常時表示の通知が出ることを仕様とする。
    * **iOS:** Core Bluetooth Background Execution Modesを利用し、バックグラウンドでの検知が**数分単位で遅延する**ことを仕様とする。
    * **ユーザーへの案内:** アプリ内のFAQなどで、「すれ違いの精度を上げるには、アプリを開いておくのがおすすめです」といった案内を行うことを検討する。

## 7. 方針サマリー

| 項目 | フェーズ1 (初期実装) | フェーズ2 (将来的な最適化) | 決定理由 |
| :--- | :--- | :--- | :--- |
| **アーキテクチャ** | ネイティブ + Platform Channel | (変更なし) | 安定性とOS機能活用の最大化 |
| **一時ID管理** | バックエンド生成 | (変更なし) | セキュリティと実装の容易性 |
| **API通信** | **即時処理** (検知ごと) | **バッチ処理** (まとめて送信) | 初期はシンプルさ、将来的に効率化 |
| **バッテリー対策** | **特に対策なし** (常時動作) | **動的制御** (状況に応じて調整) | 初期は機能実現、将来的にUX向上 |
| **BG動作** | OSの制約を前提 (ベストエフォート) | (変更なし) | 開発コストと安定性の両立 |